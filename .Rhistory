hkm_res_combined <- hkmeans(matint_combined, K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm_res_combined,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_combined,
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = df_metadata_combined$estado)) +
scale_color_manual(values = c("maroon","steelblue4","green4","steelblue4","maroon","steelblue4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_combined, center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
#
#
### PRUEBO LO MISMO SIN EL PICO DE 8MIL ########################################
################################################################################
matint_combined <- matint_combined[, 1:4]
# HKMEANS clustering con top5 y 2 clusters
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
# Realizar el clustering sobre la matriz combinada
hkm_res_combined <- hkmeans(matint_combined, K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm_res_combined,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_combined,
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = df_metadata_combined$estado)) +
scale_color_manual(values = c("grey","grey","maroon","green4","yellow4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_combined, center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
# Agregar etiquetas a los puntos de las muestras
cluster_hkmean20 <- cluster_hkmean20 +
geom_text_repel(data = cluster_hkmean20$data,
aes(x = x, y = y, label = df_metadata_combined$sexo),
color = "black",
size = 3,          # Tamaño de las etiquetas
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los nombres de las muestras
print(cluster_hkmean20)
### PRUEBO LO MISMO SIN EL PICO DE 8MIL y el de 3MIL ###########################
################################################################################
matint_combined <- matint_combined[, -2]
# HKMEANS clustering con top5 y 2 clusters
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
# Realizar el clustering sobre la matriz combinada
hkm_res_combined <- hkmeans(matint_combined, K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm_res_combined,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_combined,
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = df_metadata_combined$estado)) +
scale_color_manual(values = c("grey","grey","maroon","green4","yellow4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_combined, center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
################ MALDI-TOF ANALISIS VINCHUCA ###################################
################ 1) NO SUPERVISADO - 19 INDIVIDUOS  ############################
#
# Autor: Bioing. Facundo Urteaga (IBB-CONICET)
#
#
### CARGA DE LIBRERIAS #########################################################
################################################################################
library("readBrukerFlexData")
library("binda")
library("fs")
library("readxl")
library("MALDIquant")
library("MALDIquantForeign")
library("MALDIrppa")
library("tidyverse")
library("dplyr")
library("clValid")
library(cluster)
library(factoextra)
library(ggplot2)
library(gridExtra)
library(ggrepel)
### CARGA DE ARCHIVOS ##########################################################
################################################################################
# Creación de la ruta relativa de los archivos
#ruta_proyecto <- "C:/Users/urtea/OneDrive/Documents/Proyectos/MALDI_Vinchucas"
ruta_proyecto <- "C:/Users/Facundo/Documents/Proyectos/MALDI_Vinchucas"
ruta_datos <- file.path(ruta_proyecto)
# Load the Rdata files using the relative path
load(file.path(ruta_datos, "matint_19_ind_dico.Rdata"))
load(file.path(ruta_datos, "matint_19_ind.Rdata"))
### SELECCIÓN DE PICOS #########################################################
################################################################################
# Selección de picos para binary discriminant analysis (BDA)
factor_tipo <- factor(df_metadata_prom_mue$estado)
is.binaryMatrix(matint_19_ind_dico) # TRUE
br <- binda.ranking(matint_19_ind_dico, factor_tipo, verbose = FALSE)
# Gráfico de picos vs score
nueva_columna <- c()
matriz <- matrix(br, nrow = 244, ncol = 4) #244 es la cantidad de picos
for (i in 1:244) {
nuevo_valor <- colnames(matint_19_ind_dico)[br[i]]
nueva_columna<- c(nueva_columna, nuevo_valor)
}
matriz <- cbind(matriz, nueva_columna)
df_br <- data.frame(matriz)
plot(df_br$nueva_columna, df_br$V2,
xlab = "m/z", ylab = "Score",
main = "Ranking de picos de los espectros")
# Crear un gradiente de colores (por ejemplo, de azul a rojo)
colores <- colorRampPalette(c("green4", "red2"))(244)
# Agregar puntos con colores en forma de gradiente
for (i in 1:244) {
points(df_br$nueva_columna[i], df_br$V2[i], col = colores[i])
}
# Agregar puntos con relleno de colores en forma de gradiente
for (i in 1:244) {
points(df_br$nueva_columna[i], df_br$V2[i], pch = 19, col = colores[i])
}
# Selección de picos mas preponderantes
top.b5 <- br[1:5]  ## primeros 5 picos
top.b10 <- br[1:10]  ## primeros 10 picos
top.b15 <- br[1:15]  ## primeros 15 picos
top.b20 <- br[1:20]  ## primeros 20 picos
top.b30 <- br[1:30]  ## primeros 30 picos
top_actual <- top.b30
# Elección de mejores algoritmos de clustering
comparacion <- clValid(
obj        = matint_19_ind_dico[, top_actual],
nClust     = 2:6,
clMethods  = c("hierarchical", "kmeans", "pam"),
validation = c("stability", "internal")
)
summary(comparacion)
optimalScores(comparacion) #Se puede ir probando con distintos top picos
### ALGORITMO DE CLUSTERING ####################################################
################################################################################
# HKMEANS clustering con top5 y 2 clusters
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
hkm.res20 <- hkmeans(matint_19_ind[, top_actual],
K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm.res20,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_19_ind[, top_actual],
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = factor_tipo)) +
scale_color_manual(values = c("maroon","steelblue4","maroon","steelblue4","maroon","steelblue4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
matint_19_top <- matint_19_ind[, top_actual]
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_19_ind[, top_actual], center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
### PRUEBA CON NUEVOS PICOS ####################################################
################################################################################
# Load the Rdata files using the relative path
load(file.path(ruta_datos, "matint_9_inf.Rdata"))
# Renombrar las columnas de matint_9_inf con los nombres de los picos seleccionados
colnames(matint_selected) <- var_names
####### PRUEBA 1) REALIZO NUEVO PCA CON PRIMEROS VALORES, Y LUEGO AGREGO PUNTOS
# Cargar librerías necesarias
library(ggplot2)
library(ggrepel)
# Realizar el PCA sobre matint_19_top
pca_res <- prcomp(matint_19_top, center = TRUE, scale. = TRUE)
# Obtener las coordenadas de las muestras en los dos primeros componentes principales
pca_coords <- as.data.frame(pca_res$x[, 1:2])
# Agregar la metadata sobre el estado de infección
pca_coords$estado <- df_metadata_prom_mue$estado  # Asumiendo que df_metadata_prom_mue$estado tiene el mismo orden
# Graficar los puntos del PCA coloreados por estado de infección
pca_plot <- ggplot(pca_coords, aes(x = PC1, y = PC2, color = estado)) +
geom_point(size = 3) +
labs(title = "PCA de matint_19_top", x = "PC1", y = "PC2") +
theme_minimal()
# Mostrar el gráfico inicial
print(pca_plot)
# Obtener las medias y desviaciones estándar de matint_19_top
medias <- colMeans(matint_19_top)
desviaciones <- apply(matint_19_top, 2, sd)
# Centrar y escalar matint_selected usando las mismas medias y desviaciones
matint_selected_scaled <- sweep(matint_selected, 2, medias, "-")
matint_selected_scaled <- sweep(matint_selected_scaled, 2, desviaciones, "/")
# Proyectar los nuevos datos escalados en el espacio del PCA
pca_coords_selected <- as.data.frame(as.matrix(matint_selected_scaled) %*% pca_res$rotation[, 1:2])
# Añadir una columna indicando que estos son los nuevos puntos
pca_coords_selected$estado <- "Nuevo"
# Cambiar los nombres de las columnas para que coincidan con el formato del PCA original
colnames(pca_coords_selected) <- c("PC1", "PC2", "estado")
# Unir las coordenadas originales con las nuevas
pca_coords_combined <- rbind(pca_coords, pca_coords_selected)
# Graficar las muestras originales y los nuevos puntos
pca_plot_final <- ggplot(pca_coords_combined, aes(x = PC1, y = PC2, color = estado)) +
geom_point(size = 3) +
labs(title = "PCA de matint_19_top con nuevos puntos", x = "PC1", y = "PC2") +
scale_color_manual(values = c("red", "blue", "green")) +  # Colores para infectados, no infectados y nuevos puntos
theme_minimal()
# Mostrar el gráfico final con los nuevos puntos
print(pca_plot_final)
####### PRUEBA 2) REALIZO EL NUEVO HKAMEANS CON TODOS LOS VALORES
# Combinar matint_19_top y matint_selected sin escalar
matint_combined <- rbind(matint_19_top, matint_selected)
# Cambiar "infectado" a "infectado_nuevas" en la columna 'estado' de df_metadata_ultimas
df_metadata_ultimas$estado[df_metadata_ultimas$estado == "infectado"] <- "infectado_nuevas"
# Combinar ambos dataframes
df_metadata_combined <- rbind(df_metadata_prom_mue, df_metadata_ultimas)
df_metadata_combined$factor_nuevo <- paste0(df_metadata_combined$estado, "_", df_metadata_combined$numero)
# Selección de picos para binary discriminant analysis (BDA)
factor_tipo2 <- factor(df_metadata_combined$estado)
# Renombrar las columnas de matint_9_inf con los nombres de los picos seleccionados
rownames(matint_combined) <- df_metadata_combined$factor_nuevo
# HKMEANS clustering con top5 y 2 clusters
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
# Realizar el clustering sobre la matriz combinada
hkm_res_combined <- hkmeans(matint_combined, K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm_res_combined,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_combined,
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = df_metadata_combined$estado)) +
scale_color_manual(values = c("grey","grey","maroon","green4","yellow4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_combined, center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
#
#
### PRUEBO LO MISMO SIN EL PICO DE 8MIL ########################################
################################################################################
matint_combined <- matint_combined[, 1:4]
# HKMEANS clustering con top5 y 2 clusters
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
# Realizar el clustering sobre la matriz combinada
hkm_res_combined <- hkmeans(matint_combined, K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm_res_combined,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_combined,
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = df_metadata_combined$estado)) +
scale_color_manual(values = c("grey","grey","maroon","green4","yellow4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_combined, center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
# Agregar etiquetas a los puntos de las muestras
cluster_hkmean20 <- cluster_hkmean20 +
geom_text_repel(data = cluster_hkmean20$data,
aes(x = x, y = y, label = df_metadata_combined$sexo),
color = "black",
size = 3,          # Tamaño de las etiquetas
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los nombres de las muestras
print(cluster_hkmean20)
### PRUEBO LO MISMO SIN EL PICO DE 8MIL y el de 3MIL ###########################
################################################################################
matint_combined <- matint_combined[, -2]
# HKMEANS clustering con top5 y 2 clusters
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
# Realizar el clustering sobre la matriz combinada
hkm_res_combined <- hkmeans(matint_combined, K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm_res_combined,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_combined,
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = df_metadata_combined$estado)) +
scale_color_manual(values = c("grey","grey","maroon","green4","yellow4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_combined, center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
