data = matint_19_ind_dico[, top_actual],
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = factor_tipo)) +
scale_color_manual(values = c("maroon","steelblue4","maroon","steelblue4","maroon","steelblue4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_19_ind[, top_actual], center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
### LA HORA DE LA VERDAD. NUEVOS PICOS #########################################
################################################################################
# Load the Rdata files using the relative path
load(file.path(ruta_datos, "matint_9_inf.Rdata"))
# Renombrar las columnas de matint_9_inf con los nombres de los picos seleccionados
colnames(matint_selected) <- var_names
# Proyectar los datos de matint_9_inf en el espacio del PCA
pca_coords_inf <- as.matrix(matint_selected) %*% pca_res$rotation[, 1:2]
# Crear un data frame con las coordenadas proyectadas
df_pca_inf <- data.frame(PC1 = pca_coords_inf[, 1], PC2 = pca_coords_inf[, 2])
# Agregar los nuevos puntos proyectados al gráfico del clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = df_pca_inf,
aes(x = PC1, y = PC2, color = "green"),
, size = 3, shape = 17)  # Puntos verdes y en forma de triángulo
# Mostrar el gráfico actualizado con los nuevos puntos proyectados
print(cluster_hkmean20)
################ MALDI-TOF ANALISIS VINCHUCA ###################################
################ 1) NO SUPERVISADO - 19 INDIVIDUOS  ############################
#
# Autor: Bioing. Facundo Urteaga (IBB-CONICET)
#
#
### CARGA DE LIBRERIAS #########################################################
################################################################################
library("readBrukerFlexData")
library("binda")
library("fs")
library("readxl")
library("MALDIquant")
library("MALDIquantForeign")
library("MALDIrppa")
library("tidyverse")
library("dplyr")
library("clValid")
library(cluster)
library(factoextra)
library(ggplot2)
library(gridExtra)
library(ggrepel)
### CARGA DE ARCHIVOS ##########################################################
################################################################################
# Creación de la ruta relativa de los archivos
ruta_proyecto <- "C:/Users/urtea/OneDrive/Documents/Proyectos/MALDI_Vinchucas"
ruta_datos <- file.path(ruta_proyecto)
# Load the Rdata files using the relative path
load(file.path(ruta_datos, "matint_19_ind_dico.Rdata"))
load(file.path(ruta_datos, "matint_19_ind.Rdata"))
### SELECCIÓN DE PICOS #########################################################
################################################################################
# Selección de picos para binary discriminant analysis (BDA)
factor_tipo <- factor(df_metadata_prom_mue$estado)
is.binaryMatrix(matint_19_ind_dico) # TRUE
br <- binda.ranking(matint_19_ind_dico, factor_tipo, verbose = FALSE)
# Gráfico de picos vs score
nueva_columna <- c()
matriz <- matrix(br, nrow = 244, ncol = 4) #244 es la cantidad de picos
for (i in 1:244) {
nuevo_valor <- colnames(matint_19_ind_dico)[br[i]]
nueva_columna<- c(nueva_columna, nuevo_valor)
}
matriz <- cbind(matriz, nueva_columna)
df_br <- data.frame(matriz)
plot(df_br$nueva_columna, df_br$V2,
xlab = "m/z", ylab = "Score",
main = "Ranking de picos de los espectros")
# Crear un gradiente de colores (por ejemplo, de azul a rojo)
colores <- colorRampPalette(c("green4", "red2"))(244)
# Agregar puntos con colores en forma de gradiente
for (i in 1:244) {
points(df_br$nueva_columna[i], df_br$V2[i], col = colores[i])
}
# Agregar puntos con relleno de colores en forma de gradiente
for (i in 1:244) {
points(df_br$nueva_columna[i], df_br$V2[i], pch = 19, col = colores[i])
}
# Selección de picos mas preponderantes
top.b5 <- br[1:5]  ## primeros 5 picos
top.b10 <- br[1:10]  ## primeros 10 picos
top.b15 <- br[1:15]  ## primeros 15 picos
top.b20 <- br[1:20]  ## primeros 20 picos
top.b30 <- br[1:30]  ## primeros 30 picos
top_actual <- top.b30
# Elección de mejores algoritmos de clustering
comparacion <- clValid(
obj        = matint_19_ind_dico[, top_actual],
nClust     = 2:6,
clMethods  = c("hierarchical", "kmeans", "pam"),
validation = c("stability", "internal")
)
summary(comparacion)
optimalScores(comparacion) #Se puede ir probando con distintos top picos
### ALGORITMO DE CLUSTERING ####################################################
################################################################################
# HKMEANS clustering con top5 y 2 clusters
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
hkm.res20 <- hkmeans(matint_19_ind[, top_actual],
K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm.res20,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_19_ind_dico[, top_actual],
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = factor_tipo)) +
scale_color_manual(values = c("maroon","steelblue4","maroon","steelblue4","maroon","steelblue4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_19_ind[, top_actual], center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
### LA HORA DE LA VERDAD. NUEVOS PICOS #########################################
################################################################################
# Load the Rdata files using the relative path
load(file.path(ruta_datos, "matint_9_inf.Rdata"))
# Renombrar las columnas de matint_9_inf con los nombres de los picos seleccionados
colnames(matint_selected) <- var_names
# Proyectar los datos de matint_9_inf en el espacio del PCA
pca_coords_inf <- as.matrix(matint_selected) %*% pca_res$rotation[, 1:2]
# Crear un data frame con las coordenadas proyectadas
df_pca_inf <- data.frame(PC1 = pca_coords_inf[, 1], PC2 = pca_coords_inf[, 2])
# Agregar los nuevos puntos proyectados al gráfico del clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = df_pca_inf,
aes(x = PC1, y = PC2)
,color = "green", size = 3, shape = 17)  # Puntos verdes y en forma de triángulo
# Mostrar el gráfico actualizado con los nuevos puntos proyectados
print(cluster_hkmean20)
View(df_pca_inf)
# Verifica las dimensiones
dim(matint_9_inf)
# Verifica las dimensiones
dim(matint_selected)
dim(pca_res$rotation)
View(matint_selected)
# Asegúrate de que las columnas tengan los mismos nombres
colnames(matint_selected)
rownames(pca_res$rotation)
################ MALDI-TOF ANALISIS VINCHUCA ###################################
################ 1) NO SUPERVISADO - 19 INDIVIDUOS  ############################
#
# Autor: Bioing. Facundo Urteaga (IBB-CONICET)
#
#
### CARGA DE LIBRERIAS #########################################################
################################################################################
library("readBrukerFlexData")
library("binda")
library("fs")
library("readxl")
library("MALDIquant")
library("MALDIquantForeign")
library("MALDIrppa")
library("tidyverse")
library("dplyr")
library("clValid")
library(cluster)
library(factoextra)
library(ggplot2)
library(gridExtra)
library(ggrepel)
### CARGA DE ARCHIVOS ##########################################################
################################################################################
# Creación de la ruta relativa de los archivos
ruta_proyecto <- "C:/Users/urtea/OneDrive/Documents/Proyectos/MALDI_Vinchucas"
ruta_datos <- file.path(ruta_proyecto)
# Load the Rdata files using the relative path
load(file.path(ruta_datos, "matint_19_ind_dico.Rdata"))
load(file.path(ruta_datos, "matint_19_ind.Rdata"))
### SELECCIÓN DE PICOS #########################################################
################################################################################
# Selección de picos para binary discriminant analysis (BDA)
factor_tipo <- factor(df_metadata_prom_mue$estado)
is.binaryMatrix(matint_19_ind_dico) # TRUE
br <- binda.ranking(matint_19_ind_dico, factor_tipo, verbose = FALSE)
# Gráfico de picos vs score
nueva_columna <- c()
matriz <- matrix(br, nrow = 244, ncol = 4) #244 es la cantidad de picos
for (i in 1:244) {
nuevo_valor <- colnames(matint_19_ind_dico)[br[i]]
nueva_columna<- c(nueva_columna, nuevo_valor)
}
matriz <- cbind(matriz, nueva_columna)
df_br <- data.frame(matriz)
plot(df_br$nueva_columna, df_br$V2,
xlab = "m/z", ylab = "Score",
main = "Ranking de picos de los espectros")
# Crear un gradiente de colores (por ejemplo, de azul a rojo)
colores <- colorRampPalette(c("green4", "red2"))(244)
# Agregar puntos con colores en forma de gradiente
for (i in 1:244) {
points(df_br$nueva_columna[i], df_br$V2[i], col = colores[i])
}
# Agregar puntos con relleno de colores en forma de gradiente
for (i in 1:244) {
points(df_br$nueva_columna[i], df_br$V2[i], pch = 19, col = colores[i])
}
# Selección de picos mas preponderantes
top.b5 <- br[1:5]  ## primeros 5 picos
top.b10 <- br[1:10]  ## primeros 10 picos
top.b15 <- br[1:15]  ## primeros 15 picos
top.b20 <- br[1:20]  ## primeros 20 picos
top.b30 <- br[1:30]  ## primeros 30 picos
top_actual <- top.b30
# Elección de mejores algoritmos de clustering
comparacion <- clValid(
obj        = matint_19_ind_dico[, top_actual],
nClust     = 2:6,
clMethods  = c("hierarchical", "kmeans", "pam"),
validation = c("stability", "internal")
)
summary(comparacion)
optimalScores(comparacion) #Se puede ir probando con distintos top picos
### ALGORITMO DE CLUSTERING ####################################################
################################################################################
# HKMEANS clustering con top5 y 2 clusters
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
hkm.res20 <- hkmeans(matint_19_ind[, top_actual],
K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm.res20,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_19_ind_dico[, top_actual],
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = factor_tipo)) +
scale_color_manual(values = c("maroon","steelblue4","maroon","steelblue4","maroon","steelblue4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_19_ind[, top_actual], center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
### LA HORA DE LA VERDAD. NUEVOS PICOS #########################################
################################################################################
# Load the Rdata files using the relative path
load(file.path(ruta_datos, "matint_9_inf.Rdata"))
# Renombrar las columnas de matint_9_inf con los nombres de los picos seleccionados
colnames(matint_selected) <- var_names
# Proyectar los datos de matint_9_inf en el espacio del PCA
pca_coords_inf <- as.matrix(matint_selected) %*% pca_res$rotation[, 1:2]
# Crear un data frame con las coordenadas proyectadas
df_pca_inf <- data.frame(PC1 = pca_coords_inf[, 1], PC2 = pca_coords_inf[, 2])
colnames(df_pca_inf) <- c("x", "y")
# Agregar los nuevos puntos proyectados al gráfico del clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = df_pca_inf,
aes(x = x, y = y)
,color = "green", size = 3, shape = 17)  # Puntos verdes y en forma de triángulo
# Mostrar el gráfico actualizado con los nuevos puntos proyectados
print(cluster_hkmean20)
# Graficar los puntos de df_pca_inf
ggplot(df_pca_inf, aes(x = x, y = y)) +
geom_point(color = "green", size = 3, shape = 17) +
labs(title = "Proyección de matint_9_inf en el espacio PCA")
View(df_pca_inf)
################ MALDI-TOF ANALISIS VINCHUCA ###################################
################ 1) NO SUPERVISADO - 19 INDIVIDUOS  ############################
#
# Autor: Bioing. Facundo Urteaga (IBB-CONICET)
#
#
### CARGA DE LIBRERIAS #########################################################
################################################################################
library("readBrukerFlexData")
library("binda")
library("fs")
library("readxl")
library("MALDIquant")
library("MALDIquantForeign")
library("MALDIrppa")
library("tidyverse")
library("dplyr")
library("clValid")
library(cluster)
library(factoextra)
library(ggplot2)
library(gridExtra)
library(ggrepel)
### CARGA DE ARCHIVOS ##########################################################
################################################################################
# Creación de la ruta relativa de los archivos
ruta_proyecto <- "C:/Users/urtea/OneDrive/Documents/Proyectos/MALDI_Vinchucas"
ruta_datos <- file.path(ruta_proyecto)
# Load the Rdata files using the relative path
load(file.path(ruta_datos, "matint_19_ind_dico.Rdata"))
load(file.path(ruta_datos, "matint_19_ind.Rdata"))
### SELECCIÓN DE PICOS #########################################################
################################################################################
# Selección de picos para binary discriminant analysis (BDA)
factor_tipo <- factor(df_metadata_prom_mue$estado)
is.binaryMatrix(matint_19_ind_dico) # TRUE
br <- binda.ranking(matint_19_ind_dico, factor_tipo, verbose = FALSE)
# Gráfico de picos vs score
nueva_columna <- c()
matriz <- matrix(br, nrow = 244, ncol = 4) #244 es la cantidad de picos
for (i in 1:244) {
nuevo_valor <- colnames(matint_19_ind_dico)[br[i]]
nueva_columna<- c(nueva_columna, nuevo_valor)
}
matriz <- cbind(matriz, nueva_columna)
df_br <- data.frame(matriz)
plot(df_br$nueva_columna, df_br$V2,
xlab = "m/z", ylab = "Score",
main = "Ranking de picos de los espectros")
# Crear un gradiente de colores (por ejemplo, de azul a rojo)
colores <- colorRampPalette(c("green4", "red2"))(244)
# Agregar puntos con colores en forma de gradiente
for (i in 1:244) {
points(df_br$nueva_columna[i], df_br$V2[i], col = colores[i])
}
# Agregar puntos con relleno de colores en forma de gradiente
for (i in 1:244) {
points(df_br$nueva_columna[i], df_br$V2[i], pch = 19, col = colores[i])
}
# Selección de picos mas preponderantes
top.b5 <- br[1:5]  ## primeros 5 picos
top.b10 <- br[1:10]  ## primeros 10 picos
top.b15 <- br[1:15]  ## primeros 15 picos
top.b20 <- br[1:20]  ## primeros 20 picos
top.b30 <- br[1:30]  ## primeros 30 picos
top_actual <- top.b30
# Elección de mejores algoritmos de clustering
comparacion <- clValid(
obj        = matint_19_ind_dico[, top_actual],
nClust     = 2:6,
clMethods  = c("hierarchical", "kmeans", "pam"),
validation = c("stability", "internal")
)
summary(comparacion)
optimalScores(comparacion) #Se puede ir probando con distintos top picos
### ALGORITMO DE CLUSTERING ####################################################
################################################################################
# HKMEANS clustering con top5 y 2 clusters
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
hkm.res20 <- hkmeans(matint_19_ind[, top_actual],
K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm.res20,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_19_ind_dico[, top_actual],
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = factor_tipo)) +
scale_color_manual(values = c("maroon","steelblue4","maroon","steelblue4","maroon","steelblue4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_19_ind[, top_actual], center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
### LA HORA DE LA VERDAD. NUEVOS PICOS #########################################
################################################################################
# Load the Rdata files using the relative path
load(file.path(ruta_datos, "matint_9_inf.Rdata"))
# Renombrar las columnas de matint_9_inf con los nombres de los picos seleccionados
colnames(matint_selected) <- var_names
# Proyectar los datos de matint_9_inf en el espacio del PCA
pca_coords_inf <- as.matrix(matint_selected) %*% pca_res$rotation[, 1:2]
# Crear un data frame con las coordenadas proyectadas
df_pca_inf <- data.frame(PC1 = pca_coords_inf[, 1], PC2 = pca_coords_inf[, 2])
colnames(df_pca_inf) <- c("x", "y")
# Agregar los nuevos puntos proyectados al gráfico del clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = df_pca_inf,
aes(x = x, y = y)
,color = "green", size = 3, shape = 17)  # Puntos verdes y en forma de triángulo
# Mostrar el gráfico actualizado con los nuevos puntos proyectados
print(cluster_hkmean20)
# Graficar los puntos de df_pca_inf
ggplot(df_pca_inf, aes(x = x, y = y)) +
geom_point(color = "green", size = 3, shape = 17) +
labs(title = "Proyección de matint_9_inf en el espacio PCA")
View(pca_coords_inf)
View(pca_coords_inf)
cluster_hkmean20$data
matint_19_ind[, top_actual]
matint_selected
