var2 = 0.95
hkm.res20 <- hkmeans(matint_19_ind_dico[, top_actual],
K.num)
# cluster_hkmean20 <- fviz_cluster(hkm.res20, ellipse = FALSE, #ellipse.type = "ellipse",
#                                 data = matint_19_ind_dico[, top_actual],
#                                 ellipse.level = var2,
#                                 show.clust.cent = F,
#                                 geom = "point", main = "INF VS NO INF - hkmeans - Top 20 - 2 cluster")
#
# # Personalización del ploteo
# cluster_hkmean20 <- cluster_hkmean20 +
#   geom_point(data = cluster_hkmean20$data,
#              aes(x = x, y = y, color = factor_tipo)) +
#   scale_color_manual(values = c("maroon","steelblue4","steelblue4", "maroon" )) +
#   scale_size_continuous(range = c(2, 4)) +
#   labs(color = "Cluster", size = "Sexo") +
#   theme(legend.position = "right")
#
# # Muestra el gráfico
# print(cluster_hkmean20)
# # Recalcular el clustering y el gráfico con elipse
# cluster_hkmean20 <- fviz_cluster(hkm.res20,
#                                  ellipse.type = "norm",  # Cambiar a "norm" o "t" para ver la elipse
#                                  data = matint_19_ind_dico[, top_actual],
#                                  ellipse.level = var2, # Nivel de confianza de la elipse
#                                  show.clust.cent = TRUE,  # Mostrar el centroide de los clusters
#                                  geom = "point",
#                                  main = "INF VS NO INF - hkmeans - Top 20 - 2 clusters")
#
# # Personalización del gráfico
# cluster_hkmean20 <- cluster_hkmean20 +
#   geom_point(data = cluster_hkmean20$data,
#              aes(x = x, y = y, color = factor_tipo)) +
#   scale_color_manual(values = c("maroon","steelblue4","steelblue4", "maroon" )) +
#   scale_size_continuous(range = c(2, 4)) +
#   labs(color = "Cluster", size = "Sexo") +
#   theme(legend.position = "right")
# # Mostrar el gráfico actualizado con elipse
# print(cluster_hkmean20)
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
hkm.res20 <- hkmeans(matint_19_ind[, top_actual],
K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm.res20,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_19_ind_dico[, top_actual],
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 20 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = factor_tipo)) +
scale_color_manual(values = c("maroon","steelblue4","steelblue4", "maroon" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
# Realizar el análisis de componentes principales (PCA) sobre los datos
pca_res <- prcomp(matint_19_ind_dico[, top_actual], scale. = TRUE)
# Ver los resultados de PCA
summary(pca_res)
# Crear el biplot con los vectores de las variables
biplot_pca <- fviz_pca_biplot(pca_res,
repel = TRUE,      # Evitar superposición de etiquetas
col.var = "black", # Color de las variables (vectores)
col.ind = factor_tipo, # Color de los individuos por factor_tipo
pointsize = 2,     # Tamaño de los puntos
geom = "point",
addEllipses = TRUE, # Añadir elipses de confianza
ellipse.level = var2,  # Nivel de confianza de las elipses
title = "Biplot - PCA con vectores y clustering")
# Mostrar el biplot
print(biplot_pca)
# Obtener las coordenadas de los vectores
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Agregar los vectores al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords), aes(x = 0, y = 0,
xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text(data = as.data.frame(var_coords), aes(x = PC1, y = PC2, label = var_names),
color = "blue", vjust = 1, hjust = 1)
# Mostrar el gráfico con los vectores añadidos
print(cluster_hkmean20)
install.packages("ggrepel")
install.packages("ggrepel")
################ MALDI-TOF ANALISIS VINCHUCA ###################################
################ 1) PREPROCESAMIENTO  ##########################################
#
# Autor: Bioing. Facundo Urteaga (IBB-CONICET)
#
#
### CARGA DE LIBRERIAS #########################################################
################################################################################
library(binda)
library(here)
library(dplyr)
library(readBrukerFlexData)
library(MALDIquant)
library(MALDIquantForeign)
library(MALDIrppa)
library(stringr)
### CARGA DE ESPECTROS #########################################################
################################################################################
# Creación de la ruta relativa de los archivos
ruta_proyecto <- "C:/Users/urtea/OneDrive/Documents/Proyectos/MALDI_Vinchucas/Datos"
ruta_datos <- file.path(ruta_proyecto)
# Importar espectros
Spectra_list <- importBrukerFlex(file.path(ruta_datos), verbose=FALSE)
### OBTENCIÓN DE METADATA DE ESPECTROS #########################################
################################################################################
# Creación de columnas vacías
col_num <- c()
col_estado <- c()
col_numero <- c()
col_sexo <- c()
col_rep_m <- c()
col_rep_t <- c()
# Patrones auxiliares para buscar el día de la muestra
patron_i <- "Vinchucas infectadas"
patron_ni <- "Vinchucas no infectadas"
# Ciclo que extrae dia, tipo, numero, well y réplica de cada muestra
for(i in 1:length(Spectra_list)) {
nombre <- Spectra_list[[i]]@metaData$file
# Encuentra la posición del patrón infectadas
posicion_i <- str_locate(nombre, patron_i)[1, 2]
# Encuentra la posición del patrón infectadas
posicion_ni <- str_locate(nombre, patron_ni)[1, 2]
# Verifica si posicion_ni es NA
if (is.na(posicion_ni)) {
posicion <- posicion_i
estado <- "infectado"
}
else {
posicion <- posicion_ni
estado <- "no infectado"
}
# Agrega estado a la columna correspondiente
col_estado <- c(col_estado, estado)
# Extrae la parte restante del nombre después del estado
resultado <- substr(nombre, (posicion+2), nchar(nombre))
# Usa expresiones regulares para extraer los datos:
# Ejemplo: "Vinchuca 1 hembra 23-05-24\\0_A1\\1\\1SLin\\fid"
numero_vinchuca <- str_extract(resultado, "Vinchuca [0-9]+") %>% str_extract("[0-9]+")
sexo <- str_extract(resultado, "hembra|macho")
replica_muestra <- str_extract(resultado, "[A-Z][0-9]+")
replica_tecnica <- str_extract(resultado, "\\\\[0-9]+\\\\1SLin") %>% str_extract("[0-9]+")
# Almacena los valores extraídos en sus respectivas columnas
col_numero <- c(col_numero, numero_vinchuca)
col_sexo <- c(col_sexo, sexo)
col_rep_m <- c(col_rep_m, replica_muestra)
col_rep_t <- c(col_rep_t, replica_tecnica)
# print(paste("Estado:", estado, "| Número:", numero_vinchuca, "| Sexo:", sexo,
#             "| Réplica Muestra:", replica_muestra, "| Réplica Técnica:", replica_tecnica))
Spectra_list[[i]]@metaData$numero_vinchuca <- numero_vinchuca
Spectra_list[[i]]@metaData$estado <- estado
Spectra_list[[i]]@metaData$sexo <- sexo
Spectra_list[[i]]@metaData$rep_m <- replica_muestra
Spectra_list[[i]]@metaData$rep_t <- replica_tecnica
# Data Frame con los datos limpios
df_metadata <- data.frame(estado = col_estado, numero = col_numero, sexo = col_sexo,
rep_m = col_rep_m, rep_t = col_rep_t)
# Creación de factores de agrupamiento para su uso posterior
df_metadata$factor_num <- paste0(df_metadata$estado, "_", df_metadata$numero)
df_metadata$factor_mue <- paste0(df_metadata$estado, "_", df_metadata$rep_m)
df_metadata$factor_sex <- paste0(df_metadata$estado, "_", df_metadata$sexo)
}
### CONTROL DE CALIDAD Y LIMPIEZA DE ESPECTROS #################################
################################################################################
# Screening inicial: Detección de espectros de baja calidad
sc.results <- screenSpectra(Spectra_list, meta = df_metadata)
summary(sc.results)
plot(sc.results, labels = TRUE)
# plot(Spectra_list[[253]]) # Ploteo de espectros ruidosos
# Descartamos espectros defectuosos
Spectra_list_f1 <- sc.results$fspectra # Filtramos espectros
df_metadata_f1 <- sc.results$fmeta # Filtramos metadatos
### FILTRADO Y TRANSFORMACIÓN DE ESPECTROS #####################################
################################################################################
# Parámetros de procesamiento de espectros
thScale <- 10 # Smoothing
ite <- 105 # Baseline correction
SigNoi <- 2.5 # Peak extraction
hws <- 20 # Peak extraction
tol <- 0.03 # Peak binning
# Transformación/filtrado/corrección de espectros con parámetros definidos
# 1) Transformación de intensidad por medio de función sqrt
Spectra_list_f1 <- transfIntensity(Spectra_list_f1, fun = sqrt)
plot(Spectra_list_f1[[30]])
# 2) Suavizado del espectro mediante el método Wavelet
Spectra_list_f1 <- wavSmoothing(Spectra_list_f1, method = "Wavelet", n.levels = 4)
plot(Spectra_list_f1[[30]])
# Detección de la linea de base
baseline <- estimateBaseline(Spectra_list_f1[[30]], method = "SNIP",
iterations = ite)
plot(Spectra_list_f1[[30]])
lines(baseline, col="red", lwd=2)
# 3) Remoción de linea de base mediante método SNIP
Spectra_list_f2 <- removeBaseline(Spectra_list_f1, method = "SNIP",
iterations = ite)
plot(Spectra_list_f2[[30]])
# 4) Calibración de intensidad mediante método PQN
Spectra_list_f2 <- calibrateIntensity(Spectra_list_f2, method = "PQN")
plot(Spectra_list_f2[[30]])
# 5) Alineación de espectros
Spectra_list_f3 <- alignSpectra(Spectra_list_f2,
halfWindowSize=20,
SNR=2,
tolerance=0.02, # Parámetro sensible
warpingMethod="lowess")
plot(Spectra_list_f3[[30]])
### PROMEDIO DE LECTURAS DE UNA MISMA RÉPLICA TÉCNICA #################
################################################################################
# Promedio de lecturas de una misma well
Spectra_list_prom_rep <- averageMassSpectra(Spectra_list_f3,
labels = factor(df_metadata_f1$factor_mue),
method = "mean")
# Creo la nueva metadata de los espectros promediados
df_metadata_prom_rep <- df_metadata_f1 %>%
distinct(factor_mue, .keep_all = TRUE)
# Promedio de wells de una misma muestra
Spectra_list_prom_muestra <- averageMassSpectra(Spectra_list_prom_rep,
labels = factor(df_metadata_prom_rep$factor_num),
method = "mean")
# Creo la nueva metadata de los espectros promediados
df_metadata_prom_mue <- df_metadata_prom_rep %>%
distinct(factor_num, .keep_all = TRUE)
### EXTRACCIÓN DE PICOS Y ALINEACIÓN ###########################################
################################################################################
# A partir de acá probamos trabajar con Spectra_list_prom_rep
# Análisis de la SNR en espectros para chequear que utilizamos el valor correcto
noise <- estimateNoise(Spectra_list_prom_rep[[20]])
plot(Spectra_list_prom_rep[[20]], xlim=c(4000, 20000), ylim=c(0, 0.002))
lines(noise, col="red")
lines(noise[,1], noise[, 2]*2, col="blue") # Se ve que es correcto el 2
# Detección de picos a partir del umbral definido de SNR
peaks <- detectPeaks(Spectra_list_prom_rep,
SNR = SigNoi,
halfWindowSize = 40)
# Ploteo de picos detectados en un espectro de ejemplo
plot(Spectra_list_prom_rep[[20]], xlim=c(4000, 20000), ylim=c(0, 0.002))
points(peaks[[20]], col="red", pch=4)
# Alineado de picos
peaks <- alignPeaks(peaks,
minFreq = 0.8,
tolerance = tol)
#summaryPeaks(peaks[1:10])  # resumen estadistico de picos (primeros 10)
# Conteo de picos por perfil
cP <- countPeaks(peaks)
# Gráfico de picos
plot(cP, type = "n")
text(cP, label = 1:length(cP))
# Patrones de picos
peakPatterns(peaks)
# Filtrado de picos de baja frecuencia de aparición
picos_filtrados <- filterPeaks(peaks,
minFreq = 0.25,
labels = df_metadata_prom_rep$factor_num ) #labels
# Patrones de picos
peakPatterns(picos_filtrados)
# Conteo de picos por perfil
cP2 <- countPeaks(picos_filtrados)
# Gráfico
plot(cP2, type = "n")
text(cP2, label = 1:length(cP2))
# Fusión de picos de la misma muestra
picos_fusion_muestra <- mergeMassPeaks(picos_filtrados,
labels = df_metadata_prom_rep$factor_num,
method = "median")
# Patrones de picos
peakPatterns(picos_fusion_muestra)
### CREACIÓN DE MATRIZ DE INTENSIDADES Y DICOTÓMICA ############################
################################################################################
# Matriz de intensidades 19 individuos
matint_19_ind <- intensityMatrix(picos_fusion_muestra,
Spectra_list_prom_muestra) # sin valores NA
# Matriz de intensidades de 80 muestras
# matint_na_51 <- intensityMatrix(picos_fusion_muestra) # con valores NA
matint_80_mue <- intensityMatrix(picos_filtrados,
Spectra_list_prom_rep) # sin valores NA
# Definición de umbrales
thr1 <- optimizeThreshold(matint_19_ind,
df_metadata_prom_mue$estado,
verbose = T)
thr2 <- optimizeThreshold(matint_80_mue,
df_metadata_prom_rep$estado,
verbose = T)
# Dicotomización
matint_19_ind_dico <- dichotomize(matint_19_ind, thr1)
matint_80_mue_dico <- dichotomize(matint_80_mue, thr2)
# Agrego nombres a las filas de cada df
rownames(matint_19_ind_dico) <- df_metadata_prom_mue$factor_num
rownames(matint_80_mue_dico) <- df_metadata_prom_rep$factor_mue
rownames(matint_19_ind) <- df_metadata_prom_mue$factor_num
rownames(matint_80_mue) <- df_metadata_prom_rep$factor_mue
### GUARDAR DATOS ##############################################################
################################################################################
# Establecer el directorio de trabajo en la ubicación del script
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # Se puede mejorar, subcarpeta
# Guardar matrices y metadata asociada como archivo .Rdata
save(matint_19_ind_dico,df_metadata_prom_mue, file = "matint_19_ind_dico.Rdata")
save(matint_80_mue_dico, df_metadata_prom_rep, file = "matint_80_mue_dico.Rdata")
save(matint_19_ind,df_metadata_prom_mue, file = "matint_19_ind.Rdata")
save(matint_80_mue, df_metadata_prom_rep, file = "matint_80_mue.Rdata")
# Guardar matrices y metadata asociada como archivo .csv
write.csv(matint_19_ind_dico, "matint_19_ind_dico.csv", row.names = TRUE)
write.csv(matint_19_ind, "matint_19_ind.csv", row.names = TRUE)
write.csv(matint_80_mue_dico, "matint_80_mue_dico.csv", row.names = TRUE)
write.csv(matint_80_mue, "matint_80_mue.csv", row.names = TRUE)
write.csv(df_metadata_prom_mue, "df_19.csv", row.names = TRUE)
write.csv(df_metadata_prom_rep, "df_80.csv", row.names = TRUE)
#
#
#
### FIN ########################################################################
################################################################################
################ MALDI-TOF ANALISIS VINCHUCA ###################################
################ 1) NO SUPERVISADO - 19 INDIVIDUOS  ############################
#
# Autor: Bioing. Facundo Urteaga (IBB-CONICET)
#
#
### CARGA DE LIBRERIAS #########################################################
################################################################################
library("readBrukerFlexData")
library("binda")
library("fs")
library("readxl")
library("MALDIquant")
library("MALDIquantForeign")
library("MALDIrppa")
library("tidyverse")
library("dplyr")
library("clValid")
library(cluster)
library(factoextra)
library(ggplot2)
library(gridExtra)
library(ggrepel)
### CARGA DE ARCHIVOS ##########################################################
################################################################################
# Creación de la ruta relativa de los archivos
ruta_proyecto <- "C:/Users/urtea/OneDrive/Documents/Proyectos/MALDI_Vinchucas"
ruta_datos <- file.path(ruta_proyecto)
# Load the Rdata files using the relative path
load(file.path(ruta_datos, "matint_19_ind_dico.Rdata"))
load(file.path(ruta_datos, "matint_19_ind.Rdata"))
### SELECCIÓN DE PICOS #########################################################
################################################################################
# Selección de picos para binary discriminant analysis (BDA)
factor_tipo <- factor(df_metadata_prom_mue$estado)
is.binaryMatrix(matint_19_ind_dico) # TRUE
br <- binda.ranking(matint_19_ind_dico, factor_tipo, verbose = FALSE)
# Gráfico de picos vs score
nueva_columna <- c()
matriz <- matrix(br, nrow = 244, ncol = 4) #244 es la cantidad de picos
for (i in 1:244) {
nuevo_valor <- colnames(matint_19_ind_dico)[br[i]]
nueva_columna<- c(nueva_columna, nuevo_valor)
}
matriz <- cbind(matriz, nueva_columna)
df_br <- data.frame(matriz)
plot(df_br$nueva_columna, df_br$V2,
xlab = "m/z", ylab = "Score",
main = "Ranking de picos de los espectros")
# Crear un gradiente de colores (por ejemplo, de azul a rojo)
colores <- colorRampPalette(c("green4", "red2"))(244)
# Agregar puntos con colores en forma de gradiente
for (i in 1:244) {
points(df_br$nueva_columna[i], df_br$V2[i], col = colores[i])
}
# Agregar puntos con relleno de colores en forma de gradiente
for (i in 1:244) {
points(df_br$nueva_columna[i], df_br$V2[i], pch = 19, col = colores[i])
}
# Selección de picos mas preponderantes
top.b5 <- br[1:5]  ## primeros 5 picos
top.b10 <- br[1:10]  ## primeros 10 picos
top.b15 <- br[1:15]  ## primeros 15 picos
top.b20 <- br[1:20]  ## primeros 20 picos
top.b30 <- br[1:30]  ## primeros 30 picos
top_actual <- top.b30
# Elección de mejores algoritmos de clustering
comparacion <- clValid(
obj        = matint_19_ind_dico[, top_actual],
nClust     = 2:6,
clMethods  = c("hierarchical", "kmeans", "pam"),
validation = c("stability", "internal")
)
summary(comparacion)
optimalScores(comparacion) #Se puede ir probando con distintos top picos
### ALGORITMO DE CLUSTERING ####################################################
################################################################################
# HKMEANS clustering con top5 y 2 clusters
top_actual <- top.b5
K.num <- 2 # clusters
var2 = 0.95
hkm.res20 <- hkmeans(matint_19_ind[, top_actual],
K.num)
# Recalcular el clustering y el gráfico con elipse
cluster_hkmean20 <- fviz_cluster(hkm.res20,
ellipse.type = "convex",  # Cambiar a "norm" o "t" para ver la elipse
data = matint_19_ind_dico[, top_actual],
ellipse.level = var2, # Nivel de confianza de la elipse
show.clust.cent = FALSE,  # Mostrar el centroide de los clusters
geom = "point",
pointsize = 2,
main = "INF VS NO INF - hkmeans - Top 5 - 2 clusters")
# Personalización del gráfico
cluster_hkmean20 <- cluster_hkmean20 +
geom_point(data = cluster_hkmean20$data,
aes(x = x, y = y, color = factor_tipo)) +
scale_color_manual(values = c("maroon","steelblue4","maroon","steelblue4","maroon","steelblue4" )) +
scale_size_continuous(range = c(2, 4)) +
labs(color = "Cluster", size = "Sexo") +
theme(legend.position = "right")
# Mostrar el gráfico actualizado con elipse
print(cluster_hkmean20)
### PCA para el biplot #########################################################
################################################################################
# Realizar PCA para obtener los componentes principales
pca_res <- prcomp(matint_19_ind[, top_actual], center = TRUE, scale. = TRUE)
# Obtener las coordenadas de los vectores (las variables)
var_coords <- pca_res$rotation[, 1:2]  # Coordenadas de las variables en los dos primeros PCs
var_names <- rownames(var_coords)  # Nombres de las variables
# Escalar las coordenadas de los vectores (para reducir la longitud de los vectores)
scale_factor <- 0.6  # Ajustar este factor para reducir más o menos el tamaño de los vectores
var_coords_scaled <- var_coords * scale_factor
# Agregar los vectores y sus etiquetas ajustadas al gráfico de clustering
cluster_hkmean20 <- cluster_hkmean20 +
geom_segment(data = as.data.frame(var_coords_scaled),
aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(length = unit(0.2, "cm")), color = "blue") +
geom_text_repel(data = as.data.frame(var_coords_scaled),
aes(x = PC1, y = PC2, label = var_names),
color = "blue",
size = 3,          # Tamaño de las etiquetas de los vectores
box.padding = 0.35, # Aumentar separación entre etiquetas
point.padding = 0.3,
segment.size = 0.2)
# Mostrar el gráfico con los vectores ajustados
print(cluster_hkmean20)
plot(Spectra_list_prom_muestra[[12]])
##### ANEXO: GRAFICO DE PICOS PREPONDERANTES ###################################
# Encontramos los índices más cercanos para cada valor de highlight_positions en el eje x
highlight_indices = [np.abs(x - pos).argmin() for pos in highlight_positions]
View(df_metadata_prom_mue)
# Puntos del eje x que queremos destacar
highlight_positions <- c(2152, 3466, 5443, 8491, 6283)
# Encontrar los índices más cercanos para cada valor en el eje x
highlight_indices <- sapply(highlight_positions, function(pos) which.min(abs(x - pos)))
##### ANEXO: GRAFICO DE PICOS PREPONDERANTES ###################################
# Puntos del eje x que queremos destacar
highlight_positions <- c(2152, 3466, 5443, 8491, 6283)
# Eje x correspondiente a las lecturas de tus espectros
x <- seq(1000, 10000, length.out = length(Spectra_list_prom_muestra[[1]]))
# Encontrar los índices más cercanos para cada valor en el eje x
highlight_indices <- sapply(highlight_positions, function(pos) which.min(abs(x - pos)))
# Colores para los puntos destacados
colors <- c(rep("blue", 2), rep("red", 3))
# Crear la gráfica
plot(x, Spectra_list_prom_muestra[[1]], type = "l", col = "black", xlab = "Mass/Charge (m/z)", ylab = "Intensity",
main = "Spectra with Highlighted Positions")
# Graficar el primer espectro
plot(Spectra_list_prom_muestra[[1]]@mass, Spectra_list_prom_muestra[[1]]@intensity, type = "l", col = "black",
xlab = "Mass/Charge (m/z)", ylab = "Intensity", main = "Spectra with Highlighted Positions")
# Graficar los demás espectros (si hay varios)
for (i in 1:length(Spectra_list_prom_muestra)) {
# Extraer los datos de masa y de intensidad
mass <- Spectra_list_prom_muestra[[i]]@mass
intensity <- Spectra_list_prom_muestra[[i]]@intensity
# Dibujar el espectro
lines(mass, intensity, col = "black")
# Resaltar puntos específicos
points(mass[highlight_indices[1:2]], intensity[highlight_indices[1:2]], col = "blue", pch = 19)
points(mass[highlight_indices[3:5]], intensity[highlight_indices[3:5]], col = "red", pch = 19)
}
# Graficar el primer espectro
plot(Spectra_list_prom_muestra[[1]]@mass, Spectra_list_prom_muestra[[1]]@intensity, type = "l", col = "black",
xlab = "Mass/Charge (m/z)", ylab = "Intensity", main = "Spectra with Highlighted Positions")
# Graficar los demás espectros (si hay varios)
for (i in 1:9) {
# Extraer los datos de masa y de intensidad
mass <- Spectra_list_prom_muestra[[i]]@mass
intensity <- Spectra_list_prom_muestra[[i]]@intensity
# Dibujar el espectro
lines(mass, intensity, col = "black")
# Resaltar puntos específicos
points(mass[highlight_indices[1:2]], intensity[highlight_indices[1:2]], col = "blue", pch = 19)
points(mass[highlight_indices[3:5]], intensity[highlight_indices[3:5]], col = "red", pch = 19)
}
# Graficar el primer espectro
plot(Spectra_list_prom_muestra[[1]]@mass, Spectra_list_prom_muestra[[1]]@intensity, type = "l", col = "black",
xlab = "Mass/Charge (m/z)", ylab = "Intensity", main = "Spectra with Highlighted Positions")
# Graficar los demás espectros (si hay varios)
for (i in 9:19) {
# Extraer los datos de masa y de intensidad
mass <- Spectra_list_prom_muestra[[i]]@mass
intensity <- Spectra_list_prom_muestra[[i]]@intensity
# Dibujar el espectro
lines(mass, intensity, col = "black")
# Resaltar puntos específicos
points(mass[highlight_indices[1:2]], intensity[highlight_indices[1:2]], col = "blue", pch = 19)
points(mass[highlight_indices[3:5]], intensity[highlight_indices[3:5]], col = "red", pch = 19)
}
